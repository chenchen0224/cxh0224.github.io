<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,深入理解JS," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/logo.ico?v=5.1.2" />






<meta name="description" content="框架篇之react：本篇博文，主要用来总结在项目中用到的React的基础知识，包括脚手架配置、JSX语法、渲染机制、钩子函数、函数式组件和声明类式组件、组件传参等等，以加深印象。">
<meta name="keywords" content="JavaScript,深入理解JS">
<meta property="og:type" content="article">
<meta property="og:title" content="框架篇之react">
<meta property="og:url" content="http://yoursite.com/2018/04/07/框架篇之react/index.html">
<meta property="og:site_name" content="风到这里就是粘">
<meta property="og:description" content="框架篇之react：本篇博文，主要用来总结在项目中用到的React的基础知识，包括脚手架配置、JSX语法、渲染机制、钩子函数、函数式组件和声明类式组件、组件传参等等，以加深印象。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/04/07/框架篇之react/QQ图片20180621123000.png">
<meta property="og:updated_time" content="2018-07-16T15:20:49.732Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="框架篇之react">
<meta name="twitter:description" content="框架篇之react：本篇博文，主要用来总结在项目中用到的React的基础知识，包括脚手架配置、JSX语法、渲染机制、钩子函数、函数式组件和声明类式组件、组件传参等等，以加深印象。">
<meta name="twitter:image" content="http://yoursite.com/2018/04/07/框架篇之react/QQ图片20180621123000.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/07/框架篇之react/"/>





  <title>框架篇之react | 风到这里就是粘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风到这里就是粘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/07/框架篇之react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxinhua">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风到这里就是粘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">框架篇之react</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T23:35:05+08:00">
                2018-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong><em>框架篇之react</em></strong>：本篇博文，主要用来总结在项目中用到的React的基础知识，包括脚手架配置、JSX语法、渲染机制、钩子函数、函数式组件和声明类式组件、组件传参等等，以加深印象。</p>
<a id="more"></a>
<h1 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h1><ol>
<li>React是一个MVC框架。特点：</li>
</ol>
<ul>
<li>划分组件开发</li>
<li>基于路由的SPA单页面开发</li>
<li>基于ES6写代码（最后部署上线时，需要把ES6编译成ES5，基于Babel来完成编译）</li>
<li>可能用到less/sass等，也需要使用对应的插件进行预编译</li>
<li>最后为了优化性能（减少HTTP请求次数），需要把JS或者CSS进行合并压缩<br>webpack完成以上页面组件合并、JS/CSS编译加合并等工作。</li>
</ul>
<ol>
<li><p>React全家桶：react / react-dom / react-router / redux / react-redux / axios / ant / dva / saga / mobx</p>
</li>
<li><p>react有两部分组成：</p>
</li>
</ol>
<ul>
<li>react：框架的核心部分，提供了Component类进行组件开发，提供了钩子函数（生命周期）<br>所有的生命周期函数都是基于回调函数完成的。</li>
<li>react-dom：把JSX语法（react独有的语法）渲染为真实DOM的组件（能够放到页面中展示的结构都叫做真实的DOM）</li>
</ul>
<h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><h2 id="安装create-react-app"><a href="#安装create-react-app" class="headerlink" title="安装create-react-app"></a>安装create-react-app</h2><p>脚手架：一个插件，基于它可以快速构建一套完整的自动化工程项目结构。<br>Vue：vue-cli<br>React：create-react-app（app：应用）</p>
<ul>
<li>安装脚手架<br>安装在全局环境下（目的：可以使用命令）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install create-react-app -g</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="项目新建、启动、打包"><a href="#项目新建、启动、打包" class="headerlink" title="项目新建、启动、打包"></a>项目新建、启动、打包</h2><ul>
<li><p>新建一个项目：<br>项目命名规范：<code>小写字母、数字、下划线、中划线</code>，不能出现大写字母、中文汉字、其它特殊符号等，（和npm发包时的命名规范一样）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create-react-app [项目名称]</div></pre></td></tr></table></figure>
</li>
<li><p>如果是克隆的别人的项目，直接安装依赖项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install 或 yarn install</div></pre></td></tr></table></figure>
</li>
<li><p>启动一个项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run start 或 yarn start</div></pre></td></tr></table></figure>
</li>
</ul>
<p>开发环境下，基于webpack编译处理，最后可以预览当前开发的项目成果（在webpack中安装了webpack-dev-server插件，基于这个插件会自动创建一个web服务[端口号是3000]），webpack会帮我们自动打开浏览器，展示页面并且监听页面，实现热更新。</p>
<ul>
<li>打包<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build 或 yarn build</div></pre></td></tr></table></figure>
</li>
</ul>
<p>将项目整体编译打包的命令，（打包会生成build文件夹，包含所有编译后的内容，上传到服务器即可）</p>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><ul>
<li>node_modules：当前项目安装的依赖包<ul>
<li>.bin：本地项目可执行命令，在package.json的scripts中配置对应的脚本即可（其中一个就是react-scripts命令）</li>
</ul>
</li>
<li><code>public</code>：存放的是当前项目的<code>HTML页面</code><br> 单页面放一个index.html，现在项目大多是单页面。<br> index.html中一般只有一个root标签，其它所有自己写的代码都是写在JS中的。</li>
<li>src：存放的是所有的JS、路由、组件等（包括需要编写的css或图片等）<ul>
<li><code>index.js</code>是当前项目的<code>主入口文件</code></li>
</ul>
</li>
<li>.gitignore：git提交时的忽略文件目录</li>
<li>packjson.json：当前项目的配置清单<br>create-react-app脚手架为了让结构目录清晰，把安装的webpack及配置文件都集成在了react-scripts模块中，放到了node_modules中。<ul>
<li><code>react-scripts</code>：集成了webpack需要的所有内容<br>babel一套<br>css处理一套<br>eslint一套<br>webpack一套<br>=&gt;没有less/sass的处理内容（项目中使用less，需要自己额外安装）<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "start": "react-scripts start",</div><div class="line">  "build": "react-scripts build",</div><div class="line">  "test": "react-scripts test --env=jsdom",</div><div class="line">  "eject": "react-scripts eject"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="修改默认配置项"><a href="#修改默认配置项" class="headerlink" title="修改默认配置项"></a>修改默认配置项</h2><p>真实项目在安装脚手架的基础上，需要额外安装一些模块，例如：react-router-dom / axios，再比如：less / less-loader…<br>情况一：安装其它的组件成功后，不需要修改webpack的配置项，此时我们直接安装，并且调取使用即可。<br>情况二：安装的插件是基于webpack处理的，也就是需要把安装的模块配置到webpack中。</p>
<ol>
<li>开启HTTPS协议模式（原理：设置环境变量HTTPS的值）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set HTTPS=true&amp;&amp;yarn start</div></pre></td></tr></table></figure>
</li>
</ol>
<p>原理：在webpackDevServer.config.js中，修改环境变量HTTPS的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> protocol = process.env.HTTPS === <span class="string">'true'</span> ? <span class="string">'https'</span> : <span class="string">'http'</span>;</div></pre></td></tr></table></figure></p>
<ol>
<li>更改端口号<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set PORT=63344&amp;&amp;yarn start</div></pre></td></tr></table></figure>
</li>
</ol>
<p>原理：在scripts / start.js中，修改DEFAULT_PORT的值（可以直接修改环境变量PORT，也可以直接修改后边的3000）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DEFAULT_PORT = <span class="built_in">parseInt</span>(process.env.PORT, <span class="number">10</span>) || <span class="number">3000</span>;</div></pre></td></tr></table></figure></p>
<ol>
<li>eject操作：把node_modules中隐藏的配置项暴露到项目中（不可逆）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn eject</div></pre></td></tr></table></figure>
</li>
</ol>
<p>提示确认是否执行，如果当前项目是基于git管理，在执行eject时，如果还有没有提交到历史区的内容，需要先提交到历史区，然后再eject，否则报错。<br>一旦暴露后，项目中多了两个文件夹config和scripts</p>
<ul>
<li>config：存放的是webpack的配置文件<ul>
<li>webpack.config.dev.js：开发环境下的配置项（yarn start）</li>
<li>webpack.config.prod.js：生产环境下的配置项（yarn build）</li>
<li>webpackDevServer.config.js：配置创建端口号为3000的服务，在浏览器预览</li>
</ul>
</li>
<li>scripts：存放的是可执行脚本的JS文件<ul>
<li>start.js：yarn start执行的JS文件</li>
<li>build.js：yarn build执行的JS问价<br>package.json文件也被修改了。</li>
</ul>
</li>
</ul>
<p>开发环境和生产环境，如何在webpack中区分环境？<br>node中的process.env用于设置环境变量，通过不同的环境变量（development和production），规定哪个环境下执行的操作（不同的环境执行不同的配置文件）。</p>
<ol>
<li>支持less<br>预览项目，也是先基于webpack编译，把编译后的内容放到浏览器中运行。如果项目中使用了less，需要修改webpack配置项，在配置项中加入less的编译工作，这样后期预来项目，会首先基于webpack对less文件进行编译。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add less less-loader</div></pre></td></tr></table></figure>
</li>
</ol>
<p>less是需要开发和生产环境都需要配置的，所以安装在全局。<br>开发环境下：在webpack.config.dev.js中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//=&gt;[DEV:159~193行]</span></div><div class="line"> &#123;</div><div class="line">   test: <span class="regexp">/\.(css|less)$/</span>,<span class="comment">//=&gt;增加less</span></div><div class="line">   use: [</div><div class="line">     <span class="comment">//...</span></div><div class="line">     &#123;</div><div class="line">           loader: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>),<span class="comment">//=&gt;增加less-loader</span></div><div class="line">     &#125;,</div><div class="line">   ],</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>生产环境下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: <span class="regexp">/\.(css|less)$/</span>,</div><div class="line">    loader: ExtractTextPlugin.extract(</div><div class="line">        <span class="built_in">Object</span>.assign(</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//...</span></div><div class="line">                use: [</div><div class="line">                    <span class="comment">//...</span></div><div class="line">                    &#123;</div><div class="line">                        loader: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>),</div><div class="line">                    &#125;</div><div class="line">                ],</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line">    ),</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="一些细节问题"><a href="#一些细节问题" class="headerlink" title="一些细节问题"></a>一些细节问题</h2><p>一个/：根目录<br>在react中，所有的逻辑都是在JS中完成的（包括页面结构的创建），如果想给当前页面导入一些CSS样式或IMG图片等内容，有两种方式：</p>
<ul>
<li><p>在JS中（JS导入的资源都会基于webpack编译）<br>基于·ES6 Module规范，import导入·（或者·CommonJS规范，require导入·）<br>=&gt;这样webpack在编译合并JS时，会把导入的资源文件等插入到页面的结构中（<code>绝对不能</code>在JS管控的结构中通过<code>相对目录./或../导入资源</code>，因为在webpack编译时，地址就不再是之前的相对地址了）<br>例如，在目录src / index.js中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*公共的样式在在index中导入*/</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./static/css/reset.min.css'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./static/images/1.jpg'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>在HTML中导入<br>HTML最后也要基于webpack编译，导入地址也<code>不建议</code>写相对地址，而是使用<code>%PUBLIC_URL%写成绝对地址</code><br>例如，在目录public / index.html中：    </p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel="stylesheet" href="%PUBLIC_URL%/css/reset.min.css"&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h1><p>JSX：<code>JavaScript + XML（HTML）</code><br>JSX可以创建一个 <code>React 元素</code>。每一个JSX只能有一个根元素。</p>
<p>和之前拼接的HTML字符串类似，都是把HTML结构代码和JS代码或者数据混合在一起，但它不是字符串。</p>
<ol>
<li><code>JSX中的{}</code>：存放JS代码，可以将数据嵌入到JSX中。</li>
</ol>
<ul>
<li><p>引用类型的值：</p>
<ul>
<li>不能直接放对象（除了给style赋值）</li>
<li>数组（数组中不能有对象，基本值或JSX元素可以）</li>
<li>函数不行（<code>自执行函数可以</code>）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(&lt;div&gt;</div><div class="line">    &lt;h2&gt;&#123;&#123;name:'xxx'&#125;&#125;&lt;/h2&gt;     NO</div><div class="line">    &lt;h3&gt;&#123;new Date()&#125;&lt;/h3&gt;       NO</div><div class="line">    &lt;h3&gt;&#123;[12,23,34]&#125;&lt;/h3&gt;       OK</div><div class="line">    &lt;h4&gt;&#123;(() =&gt; &#123;</div><div class="line">        return '呵呵';          OK：嵌入自执行函数的结果</div><div class="line">    &#125;)()&#125;&lt;/h4&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">      &#123;(function some() &#123;</div><div class="line">          console.log(1);      OK：不管是否有返回值</div><div class="line">      &#125;)()&#125;</div><div class="line">  &lt;/p&gt;</div><div class="line">&lt;/div&gt;, root);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>基本类型的值</p>
<ul>
<li>布尔类型：什么都不显示</li>
<li>null / undefined：也是JSX元素，代表的是空</li>
</ul>
</li>
<li><p>JS表达式：但是要求执行完有<code>返回的结果</code></p>
<ul>
<li>使用三元运算符解决判断操作，（if和switch都不可以）    </li>
<li>循环数组创建JSX元素（一般都是基于数组的map方法完成迭代），需要给创建的元素设置唯一的key值（当前本次循环内唯一即可）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//data：数组，存放的是对象（包含name和age两个属性）</span></div><div class="line">ReactDOM.render(&lt;ul&gt;</div><div class="line">    &#123;</div><div class="line">        data.map((item, index) =&gt; &#123;</div><div class="line">         let &#123;name, age&#125; = item;</div><div class="line">            return &lt;li key=&#123;index&#125;&gt;</div><div class="line">                &#123;name：&#125;&amp;nbsp;&amp;nbsp;&#123;age&#125;</div><div class="line">            &lt;/li&gt;;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&lt;/ul&gt;, root);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol>
<li>给JSX元素设置属性：<br>属性值对应大括号中<code>对象、函数都可以放</code>（也可以放JS表达式）<br>style属性值必须是对象（不能是样式字符串）<br>class用className代替</li>
</ol>
<h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><p>把JSX（虚拟DOM）变为真实的DOM。<br>JSX渲染机制：</p>
<ol>
<li><p>第一步，基于babel中的语法解析模块（babel-preset-react）把JSX语法编译为React.createElement(…)<br>babel是一个强大的正则解析库。</p>
</li>
<li><p>第二步，执行React.createElement(type, props, children)，创建一个对象（这个对象就是虚拟DOM）<br>这个对象的属性有</p>
<ul>
<li>type：标签名</li>
<li>props：一个对象，存放的是这个标签上的属性<ul>
<li>id</li>
<li>className</li>
<li>style</li>
<li>children：存放的是元素中的内容</li>
</ul>
</li>
<li>ref：</li>
<li>key</li>
<li>…</li>
<li>__proto__：Object.prototype</li>
</ul>
</li>
<li>第三步，基于render方法，把动态生成的虚拟DOM元素，插入到指定的容器中<br>ReactDOM.render([JSX],[container],[callback]);<ul>
<li>JSX：<code>React虚拟元素</code></li>
<li>container：容器，把元素放到页面中的那个容器中，不建议把JSX直接渲染到document.body中，一般挂载到一个ID为root的div中（根节点）。可以基于document.getElementById(‘root’)获取，也可以直接写root。</li>
<li>callback：把内容放到页面中呈现触发的回调函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(&lt;div&gt;</div><div class="line">    //...</div><div class="line">&lt;/div&gt;, root);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>生命周期函数：<br>描述一个组件或程序从创建到销毁的过程，在这个过程中，基于钩子函数完成一些操作（例如，在第一次渲染完成做什么，或者第二次即将重新渲染之前做什么。。。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static defaultProps = &#123;&#125;;//=&gt;这个是第一个执行的，执行完成后（给属性设置默认值后）才向下执行</div></pre></td></tr></table></figure>
<ol>
<li>基本流程：</li>
</ol>
<ul>
<li><code>constructor</code>：创建一个组件<br>传props，给状态初始化</li>
<li><code>componentWillMount</code>：第一次渲染之前<br>在这获取DOM元素是undefined。相当于Vue的beforeMount。</li>
<li><code>render</code>：第一次渲染</li>
<li><code>componentDidMount</code>：第一次渲染之后<br>DOM元素挂载完成，可以获取到。相当于Vue的mounted。<br>=&gt;<br>真实项目中，在DidMount这个阶段做如些处理：</li>
<li>控制状态更改的操作</li>
<li>从服务器获取数据，然后<code>修改状态信息</code>，完成<code>数据绑定</code></li>
</ul>
<p>注意：<br>在WillMount中，<br>如果直接setState修改数据，状态数据改变后，执行render和DidMount（<code>最新的state值</code>）。有一个小坑：==this.setState本身就是异步的，会通知执行render==，<code>WillMount中this.state的值还是原来的</code>。<br>如果将this.setState放在一个异步操作中（定时器和异步AJAX获取数据）完成，先执行render和DidMount，然后才异步更改状态数据，因为异步任务都要等第一次tick后（DidMount执行完）才会执行。<br>=&gt;<br>真实项目中的数据绑定，一般第一次组件渲染，绑定默认的数据，第二次才是绑定的从服务器获取的数据（有些要求我们需要根据数据是否存在判断显示隐藏等）</p>
<ol>
<li>修改流程：<br>2.1 【属性更新触发】</li>
</ol>
<ul>
<li><code>componentWillReceiveProps(nextProps, nextState)</code>：父组件调用子组件时，传递的属性发生改变后触发<br>==三种情况会触发==：<pre><code>- 父组件通过props传递的数据发生改变
- redux中的数据发生变化
- 路由切换引起的history/match/location变化会触发
</code></pre>这个方法执行完成，会接着执行should这一套修改的流程。<br>2.2【状态更新触发】<br>当<code>组件的状态数据发生改变</code>（setState）或者<code>传递给组件的属性发生改变</code>（重新调用组件传递不同的属性），都会引发render重新进行渲染（差异渲染）</li>
<li><code>shouldComponentUpdate(nextProps, nextState)</code>：是否允许重新渲染（返回true允许，则执行后面的钩子函数，不允许直接结束）<pre><code>方法中this.state.xxx获取的还是更新前的状态信息，但should方法有两个参数：
nextProps：最新修改的属性值
nextState：最新修改的状态信息
</code></pre>=&gt;<br>适合做一些拦截，防止多次重新渲染，消耗性能。</li>
<li><code>componentWillUpdate(nextProps, nextState)</code>：重新渲染之后<br>这里拿到的this.state.xxx也是更新前的数据，和should一样，也有两个参数</li>
<li><code>render</code>：第二次及以后重新渲染</li>
<li><code>componentDidUpdate</code>：重新渲染之后</li>
</ul>
<ol>
<li>卸载</li>
</ol>
<ul>
<li><code>componentWillUnmount</code>：卸载组件之前（一般不用）<br>卸载并不是销毁组件，原有渲染的内容是不消失的，只不过以后不能基于数据改变视图了。</li>
</ul>
<p><img src="./QQ图片20180621123000.png" alt="Alt text"></p>
<p><a href="https://www.jianshu.com/p/ba8c59be80b6" target="_blank" rel="external">vue与react类（对）比学习总结</a></p>
<p>注意：this.state.n++<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">	n: <span class="keyword">this</span>.state.n++</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意：this.state.n++是先执行this.state.n（异步），然后再++（同步），假如n初始值为0，同步++先执行，变为1，主栈空闲时执行异步代码，又变为0。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>按照组件/模块管理的方式来构建程序，也就是把一个程序划分为一个个的组件来单独处理。<br>优势：多人协作开发，组件被复用。<br>组件的存放目录：src-&gt;component</p>
<p>react创建组件有两种方式：<br>函数声明式和基于Component类创建组件</p>
<h2 id="函数声明式"><a href="#函数声明式" class="headerlink" title="函数声明式"></a>函数声明式</h2><ol>
<li>基础语法：</li>
</ol>
<ul>
<li>每一个组件都要导入一个react，因为需要基于它的createElement把JSX进行解析渲染。</li>
<li>函数返回结果是一个新的React元素（也就是当前组件的JSX结构）</li>
<li><code>props</code>变量存储的是一个<code>对象</code>，包含了调取组件时传递的属性值（不传递是一个空对象）<pre><code>- children：（单闭合和双闭合组件标签区别）
    + 组件没有子元素时，是undefined
    + 组件有子元素时，可只是一个值或一个数组，可能每一项是一个字符串，也可能是一个`对象`等（`{}中可以放react自己生成的对象`，比如props.children）
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123;con, lx&#125; = props;</div><div class="line">    <span class="keyword">let</span> title = lx === <span class="number">1</span> ? <span class="string">'系统提示'</span> : <span class="string">'系统警告'</span>;</div><div class="line">    <span class="keyword">return</span> &lt;section&gt;</div><div class="line">        &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</div><div class="line">        &lt;div&gt;&#123;con&#125;&lt;/div&gt;</div><div class="line">        &#123;props.children&#125;</div><div class="line">        &#123;</div><div class="line">            React.Children.map(props.children, item =&gt; item)</div><div class="line">        &#125;</div><div class="line">    &lt;/section&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>React中提供了<code>Children对象</code>，对象中的map、forEach等方法专门用于遍历props.children。</p>
<ol>
<li><p>使用：<br>在JSX中调取组件：只需要把组件当做一个标签使用（单闭合、双闭合都可以）<br>传递给组件的属性值：不是字符串的，要放在{}中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(&lt;div&gt;</div><div class="line">    &lt;Dialog/&gt;</div><div class="line">    &lt;Dialog con=&apos;哈哈&apos; lx=&#123;1&#125;&gt;</div><div class="line">        &lt;span&gt;1&lt;/span&gt;</div><div class="line">    &lt;/Dialog&gt;</div><div class="line">&lt;/div&gt;, root);</div></pre></td></tr></table></figure>
</li>
<li><p>渲染机制<br>createElement在处理时，遇到一个组件，type就不再是字符串标签名，而是一个函数（类），但是属性还是存在props中的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	type:Dialog,//=&gt;组件Dialog</div><div class="line">	props:&#123;</div><div class="line">		lx:1,</div><div class="line">		con:&apos;xxx&apos;,</div><div class="line">		children:一个值或一个数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>==render渲染时，需要做处理==：</p>
<ul>
<li>首先判断type的类型，如果是字符串，就创建一个标签元素，如果是函数或者类，就<code>把函数执行，把props中的每一项（包含children）传递给函数</code>。</li>
<li>在执行函数时，把函数中return的JSX转换为新对象（通过createElement），然后把这个对象返回。紧接着render按照以往的渲染方式，创建DOM元素，插入到指定的容器中。</li>
</ul>
<h2 id="继承类式（Component类）"><a href="#继承类式（Component类）" class="headerlink" title="继承类式（Component类）"></a>继承类式（Component类）</h2><ol>
<li>两种创建类方式，在渲染机制上的区别：<br>基于createElement把JSX转换为一个对象，当render渲染这个对象时，遇到type是一个函数或者类，不是直接创建元素，而是先把方法执行：</li>
</ol>
<ul>
<li>函数声明式组件：就把它当做<code>普通方法执行</code>（严格模式下，方法中的this是<code>undefined</code>），把函数返回的JSX元素（也是解析后的对象）进行渲染。</li>
<li>类声明式组件：把<code>当前类new执行</code>，创建类的一个实例（当前本次调取的组件就是它的一个实例），执行constructor之后，会执行this.render()，把render中返回的JSX拿过来渲染。=&gt;类声明式组件，<code>必须有一个render的方法</code>，方法中需要<code>返回一个JSX元素</code>（返回12也可以）。</li>
</ul>
<p>不管是哪种方式，最后都会把解析出来的<code>props属性对象作为实参</code>传递给对应的函数或者类。</p>
<ol>
<li>super()相当于<code>React.Component.call(this)</code><br>function Component(props, context, updater){…}<br><code>super()</code>，虽然创建实例时把属性传递进来了，但是并没有传递给父组件，也就是没有把属性挂载到实例上，使用this.props获取的结果是undefined<br><code>super(props)</code>，在继承父类私有时，就把传递的属性挂载到了子类的实例上，constructor就可以使用this.props了。</li>
</ol>
<p>即使在constructor中不设置形参props接收属性，执行super时也不传这个属性，除了constructor中不能直接使用this.props，<code>其它生命周期函数中都可以使用</code>（也就是执行完成constructor，react已经帮我们把传递的属性接收，并且挂载到实例上了）。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>函数声明式：</p>
<ul>
<li>操作简单</li>
<li>能实现的功能，只是简单的调取和返回JSX而已</li>
<li>函数式组件可以理解为<code>静态组件</code>（组件的内容调取是就已经固定了，很难修改）<br>所谓函数式组件是静态组件：和执行普通函数一样，调取一次组件，就把组件中的内容获取到，插入到页面中。如果不重新调取组件，显示的内容是不会发生任何改变的。<br>适用于：<code>调取一次组件，以后组件中的内容不会再次改变的情况</code>，例如，获取数据，绑定HTML<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Clock() &#123;</div><div class="line">    return &lt;section&gt;</div><div class="line">        &lt;h3&gt;当前北京时间是：&lt;/h3&gt;</div><div class="line">        &lt;div style=&#123;&#123;fontSize: &apos;20px&apos;, lineHeight: &apos;2&apos;&#125;&#125;&gt;</div><div class="line">            &#123;new Date().toLocaleString()&#125;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/section&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(() =&gt; &#123;</div><div class="line">    ReactDOM.render(&lt;Clock/&gt;, root);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>继承类式：</p>
<ul>
<li>操作相对复杂一些，但是可以实现更为复杂的业务功能</li>
<li>能够使用生命周期函数操作业务</li>
<li>继承类式，可以基于组件内部的状态（state）来动态更新渲染组件的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Clock extends React.Component &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        super();</div><div class="line">        //=&gt;初始化组件的状态</div><div class="line">        this.state = &#123;</div><div class="line">            time: new Date().toLocaleString()</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    componentDidMount() &#123;</div><div class="line">        setInterval(() =&gt; &#123;</div><div class="line">            this.setState(&#123;//异步操作</div><div class="line">                time:new Date().toLocaleString()</div><div class="line">            &#125;,()=&gt;&#123;</div><div class="line">            &#125;);</div><div class="line">        &#125;, 1000);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;section&gt;</div><div class="line">            &lt;h3&gt;当前北京时间是：&lt;/h3&gt;</div><div class="line">            &lt;div style=&#123;&#123;fontSize: &apos;20px&apos;, lineHeight: &apos;2&apos;&#125;&#125;&gt;</div><div class="line">                &#123;this.state.time&#125;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/section&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(&lt;Clock/&gt;, root);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性（props）和状态（state）"><a href="#属性（props）和状态（state）" class="headerlink" title="属性（props）和状态（state）"></a>属性（props）和状态（state）</h2><ol>
<li>props<br>属性（props）：<code>[只读]</code>，调取组件时传递进来的信息。<br>函数或类的方法来声明组件，都有props属性，都无法修其自身 props。</li>
</ol>
<p>props是只读的，我们无法在方法中修改它的值，但是可以给其设置默认值或者设置一些规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static defaultProps = &#123;</div><div class="line">    lx: &apos;系统提示&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>安装prop-types插件：给组件传递的属性设置规则（设置的规则不会影响组件渲染，但会在控制台抛出警告错误）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static propTypes = &#123;</div><div class="line">    // con:PropTypes.string,//=&gt;传递的内容是字符串</div><div class="line">    con: PropTypes.string.isRequired,//=&gt;传递的内容不仅是字符串，并且必须传递</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ol>
<li>state<br>状态（state）：<code>[读写]</code>，自己在组件中设定和规划的（<code>只有类声明式组件</code>才有状态管控，函数式组件没有）</li>
</ol>
<ul>
<li><p>初始化组件的状态为一个<code>对象</code>：在constructor中把后期需要使用的状态全部初始化一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化之后，可以通过this.state来获取。</p>
</li>
<li>基于setState修改组件状态（Component.prototype.setState）<br><code>异步操作</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Component.prototype.setState = function (partialState, callback)&#123;</div><div class="line">	//=&gt;callback：当部分状态修改，组件把对应的部分元素渲染完成执行的回调函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>1）修改部分状态：只对该初始化的状态对象的一部分属性或全部属性，修改哪个写哪个<br>2）当状态修改完成，会通知react把组件JSX中的部分元素重新进行渲染。<br>组件状态类似于Vue中的数据data，数据绑定时，是基于状态值绑定的，当修改组件状态后，对应的JSX元素也会跟着重新渲染（差异渲染：只把数据改变的部分重新渲染，基于DOM-DIFF算法完成）。</p>
<ol>
<li>区别</li>
</ol>
<p>props和state的区别：<br>state是组件的私有数据，props是父组件传递过来的<br>props是只读的<br>state可以调用this.setState修改state值（不可以直接修改this.state！）<br>state代表的是子组件自身的内部状态。从语义上讲，改变组件的状态，可能会导致dom结构的改变或者重新渲染。<br>无论是state改变，还是父组件传递的 props改变，render方法都可能会被执行。 </p>
<p>框架最重要的核心思想就是：数据操控视图（视图影响数据），告别JQ手动操作DOM的时代。<br>在react中，</p>
<ul>
<li>基于数据驱动（修改状态数据，react会重新渲染视图）完成的组件叫做受控组件（受数据控制的组件）</li>
<li>基于ref操作DOM实现视图更新的，叫做非受控组件<br>=&gt;真实项目建议使用受控组件</li>
</ul>
<p>react：[MVC] 数据更改视图跟着更改（原本是单向数据绑定）<br>但是可以构建出双向的效果。<br>使用change事件</p>
<h2 id="复合组件传参"><a href="#复合组件传参" class="headerlink" title="复合组件传参"></a>复合组件传参</h2><blockquote>
<p>父组件传递数据给子组件：<br>基于属性传递（传递是单方向的）：<br>1）父组件中：在子组件标签上添加属性<br>2）子组件中：通过this.props.[属性名]获取传递的信息</p>
</blockquote>
<p>子组件中的数据需要修改：可以让父组件传递给子组件的信息发生变化（也就是调用子组件时传递的属性发生变化，子组件会重新渲染=&gt;触发componentWillReceiveProps钩子函数）</p>
<blockquote>
<p>子组件修改父组件的状态：<br>1）把父组件的一个方法，作为属性传递给子组件<br>2）在子组件中，执行基于属性传递过来的方法。（相当于在执行父组件中的方法：而这个方法完全可以操作父组件中的信息）</p>
</blockquote>
<h1 id="组件传参"><a href="#组件传参" class="headerlink" title="组件传参"></a>组件传参</h1><h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件：父组件嵌套子组件<br>父传子</p>
<ol>
<li>属性传递（props）：<br>调取子组件时，把信息基于属性的方式传递给子组件（子组件用props接收传递的信息）（只能父传子，不能子传父，基于属性传递信息是单向传递的）</li>
</ol>
<ol>
<li>上下文传递（context）<br>父组件先把需要传给后代元素（包括孙子元素）的信息都设置好（设置在上下文中）后代组件需要用到父组件中的信息，主动去父组件中调取使用即可。</li>
</ol>
<ul>
<li>在父组件中：<br>1）设置子组件上下文属性值类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	 <span class="comment">//=&gt;父组件设置信息</span></div><div class="line">	 <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">	     <span class="comment">//=&gt;设置上下文中信息值的类型</span></div><div class="line">	     n: PropTypes.number,</div><div class="line">	     m: PropTypes.number</div><div class="line">	 &#125;;</div><div class="line"><span class="string">``</span><span class="string">`   </span></div><div class="line"><span class="string">2）获取（设置）子组件的上下文，返回什么就传递给子组件什么</span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript</div><div class="line">	 getChildContext() &#123;</div><div class="line">	     <span class="comment">//-&gt;RETURN的是啥，相当相当于往上下文中放了啥</span></div><div class="line">	     <span class="keyword">let</span> &#123;<span class="attr">count</span>: &#123;n = <span class="number">0</span>, m = <span class="number">0</span>&#125;&#125; = <span class="keyword">this</span>.props;</div><div class="line">	     <span class="keyword">return</span> &#123;</div><div class="line">	         n,</div><div class="line">	         m</div><div class="line">	     &#125;;</div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<code>只要RENDER重新渲染，就会执行getChildContext这个方法</code>，重新更新父组件中的上下文信息（render=&gt;context=&gt;子组件调取渲染）；如果父组件上下文信息更改了，子组件在重新调取的时候，会使用最新的上下文信息；   </p>
<ul>
<li>在子组件中：<br>设置传递进来的上下文类型：设置哪个类型，子组件context才有哪个类型<br>this.context.xxx<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//=&gt;子组件主动获取需要的信息</span></div><div class="line"><span class="keyword">static</span> contextTypes = &#123;</div><div class="line">    <span class="comment">//=&gt;首先类型需要和设置时候类型一样，否则报错；并且你需要用啥，就写啥即可；</span></div><div class="line">    n: PropTypes.number,</div><div class="line">    m: PropTypes.number</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>子组件怎么获取：<code>this.context.[父组件的上下文暴露出来的]</code></p>
<ol>
<li>属性 VS 上下文</li>
</ol>
<ul>
<li>属性操作简单，子组件被动接收传递的值（组件内的属性是只读的），只能父传子（子传父不行，父传孙也需要：父传子，子再传孙）</li>
<li>上下文操作起来相对复杂，子组件是主动获取信息使用的，子组件可以修改获取到的上下文信息，但是不会影响到父组件中的信息，其它组件也不受影响。<br>一旦父组件设置了上下文信息，它的后代组件都可以直接拿来用，不需要一层层传递。<br>=&gt;<br>【其实，子组件可以修改父组件的信息】<br>利用回调函数机制：父组件把一个函数通过属性或上下文的方式传递给子组件，子组件中只要把这个方法执行即可（也就是子组件中执行了父组件方法，还可以传递一些值过去），这样父组件在这个方法中，想把自己的信息改成啥就改成什么。</li>
</ul>
<h2 id="平行组件"><a href="#平行组件" class="headerlink" title="平行组件"></a>平行组件</h2><p>平行组件：兄弟组件或毫无关系的两个组件</p>
<ul>
<li>方案一：让两个平行组件有一个共同的父组件<br>父：Parent<br>子：A / B<br>父组件中的信息，父组件把信息传递给A，A中把方法执行（方法执行修改父组件信息值），父组件再把最新的信息传递给B即可，等价于A操作，影响了B。</li>
<li>方案二：基于redux进行状态管理，实现组件之间的信息传输（常用方案）</li>
</ul>
<p>组件在什么情况下会重新渲染：<br>组件状态变化<br>属性变化<br>上下文变化</p>
<p>&lt;- - - 本文 ღ 结束 - - - &gt;</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/深入理解JS/" rel="tag"># 深入理解JS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/02/深入理解JS系列-Part7（跨域）/" rel="next" title="深入理解JS系列-Part7（跨域）">
                <i class="fa fa-chevron-left"></i> 深入理解JS系列-Part7（跨域）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/22/框架篇之react-router/" rel="prev" title="框架篇之react-router">
                框架篇之react-router <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/head.jpg"
              alt="chenxinhua" />
          
            <p class="site-author-name" itemprop="name">chenxinhua</p>
            <p class="site-description motion-element" itemprop="description">从现在开始，种一棵树</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cxh0224" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#React介绍"><span class="nav-number">1.</span> <span class="nav-text">React介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#脚手架"><span class="nav-number">2.</span> <span class="nav-text">脚手架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装create-react-app"><span class="nav-number">2.1.</span> <span class="nav-text">安装create-react-app</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目新建、启动、打包"><span class="nav-number">2.2.</span> <span class="nav-text">项目新建、启动、打包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目目录结构"><span class="nav-number">2.3.</span> <span class="nav-text">项目目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改默认配置项"><span class="nav-number">2.4.</span> <span class="nav-text">修改默认配置项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些细节问题"><span class="nav-number">2.5.</span> <span class="nav-text">一些细节问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSX语法"><span class="nav-number">3.</span> <span class="nav-text">JSX语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#渲染"><span class="nav-number">4.</span> <span class="nav-text">渲染</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#钩子函数"><span class="nav-number">5.</span> <span class="nav-text">钩子函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件"><span class="nav-number">6.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明式"><span class="nav-number">6.1.</span> <span class="nav-text">函数声明式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承类式（Component类）"><span class="nav-number">6.2.</span> <span class="nav-text">继承类式（Component类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">6.3.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性（props）和状态（state）"><span class="nav-number">6.4.</span> <span class="nav-text">属性（props）和状态（state）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合组件传参"><span class="nav-number">6.5.</span> <span class="nav-text">复合组件传参</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件传参"><span class="nav-number">7.</span> <span class="nav-text">组件传参</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复合组件"><span class="nav-number">7.1.</span> <span class="nav-text">复合组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平行组件"><span class="nav-number">7.2.</span> <span class="nav-text">平行组件</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenxinhua</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
