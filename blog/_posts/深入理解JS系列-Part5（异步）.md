---
title: 深入理解JS系列-Part5（异步）
date: 2018-01-16 22:52:29
categories: 读书笔记
tags:
- JavaScript
- 深入理解JS
---
本篇是***深入理解JS系列 ***的Part5：异步。还以为JS代码时自上而下一行一行执行的吗？今天我们就来总结一下，什么是异步，以及常见的异步操作，这对于我们理解JS的执行机制非常有帮助。

<!-- more -->

# 什么是异步
## 单线程
JS 是单线程的语言，所谓“单线程”就是一根筋，对于拿到的程序，一行一行的执行，上面的执行未完成，就傻傻的等着。
JS是单线程执行的，就是说同一时刻内只会有一段代码在JS引擎内运行。

浏览器是多线程的
一般而言，浏览器在运行时常驻三个线程：
JS引擎线程：负责执行js代码
GUI渲染线程：负责渲染页面
事件队列线程：异步代码队列
其中，JS引擎线程是主线程，它和GUI渲染线程同时只有一个线程在运行，另一个线程被挂起。js涉及页面交互，可能引发页面重绘，重绘工作要等到js引擎空闲时运行。事件队列是异步代码执行之前的排队等候区。主线程执行到异步代码时，会将异步事件推入事件队列中排队，js引擎空闲时，会按顺序从队列中提取事件并执行。

因此，单线程指的是JS引擎同一时刻只能执行一段代码，是语言行为；异步操作的实现是由多线程的浏览器中的js引擎和事件队列共同完成，是浏览器行为。

另外，由JS引擎线程和GUI渲染线程互斥可以知道，js导致页面重绘实际上也是异步的，代码中改变DOM之后页面并不会立刻更新。

## 任务队列
### 同步任务
### 异步任务
任务队列是异步任务执行之前的排队等候区。

## Event-loop 
Event Loop执行机制：
1. 在主任务队列自上而下执行时，如果遇到一个异步任务，没有立即执行，而是把它放到等待任务队列中排队。
2. 当主任务队列完成后，才会到等待任务任务队列中进行查找（主任务队列完不成，不管等待任务队列中是否有到达时间。都不处理，继续等待主任务队列完成）
JS在等待任务队列中什么也不干，浏览器会安排一个监听者
3. 等待任务队列中，谁达到条件了（如果有很多都达到条件了。谁先达到的，就先处理谁），就把这个任务推入主任务队列执行。

# 常见的异步操作
哪些语句会执行异步任务，这些任务放入异步任务队列的时机？
宏任务：
- 定时器
- 事件绑定
- ajax
- 回调函数
- Node中fs可以进行异步的I / O操作
微任务：
- Promise（async / await）
- process.nextTick

执行顺序：sync -> 微任务 -> 宏任务

## setTimeout和setInterval
时机：当运行栈中的同步任务执行完毕，timer模块开始处理setTimeout，在设定的时间到了之后，会将推入异步任务队列。

## DOM事件
比如我们用AddEventListner()在按钮上注册了一个事件，浏览器的某个模块接收后先放着。当事件被触发时，浏览器的某个模块就开始把我们注册的事件的函数体扔到异步队列当中，如果执行栈中没有正在执行的任务，就会到异步队列中拿过来执行。
这就可以解释，当JS在执行时，点按钮卡着了，因为执行栈中有任务在执行，根本就没有去读取任务队列。


## ajax中的异步
从send发送请求这步开始，`当前AJAX任务开始`，如果AJAX是同步的，后续代码不会执行，要等到AJAX状态成功后再执行，反之异步不会。
xhr.send([请求主体内容]);
+ 没有请求主体，为null；
+ 有请求主体，一般是字符串，可能是JSON格式、XML格式、普通字符串格式的。
=>真实项目中常用的是`URL-encode格式`的字符串（"id=1000&lx=2000"）
响应
responseText获得字符串形式的响应数据。
```javascript
let xhr=new XMLHttpRequest();
xhr.open('GET','/temp/list',false);
xhr.onreadystatechange=()=>{
   if(xhr.readyState===2){console.log(1);}//=>监听到了状态改变为2，但主任务队列AJAX任务没有完成，被占着，没有执行
   if(xhr.readyState===4){console.log(2);}
};
xhr.send();//=>任务开始（同步：只要当前AJAX任务没有完成，就什么也不做不了）
console.log(3);
//=>2 3
```
当AJAX任务开始，由于是同步编程，主任务队列在状态没有变成4（任务结束）之前一直被这件事占用着，其它事情都做不了
==AJAX同步的弊端：==
1）阻塞下边同步代码的执行
2）阻碍自己状态的监听。只有在状态变为4时，才触发readystatechange事件绑定的方法。
（当服务器把响应头返回的时候，状态为2，触发了事件readystatechange，但是由于主任务队列没有完成，被占着呢，绑定的方法也无法执行... 所有只有状态为4的时候执行一次这个方法）
==AJAX任务执行的一个特殊性：==
当AJAX任务是同步任务时，AJAX完成会`优先执行自己的readystatechange事件（虽然这个事件在等待任务队列）`，然后才执行后边的同步代码。例如，上边的栗子输出的是2 3，而不是3 2。

## ES6中的Promise
ES6引入的Promise本身是同步的，但它可以管控异步操作。Promise并不是完全同步，当在excutor中执行resolve / reject时，此时是异步操作，会先执行then / catch等，当主栈完成后，才会再去调用resolve / reject，把存放的方法执行。
时机：执行器函数执行到resolve()时，会触发一个异步操作，将传入then()和catch()的回调函数推入任务队列。

应用
- 解决js的回调地狱
自从有了Promise，就不用在一层一层的嵌套回调函数了。

- 参数传递
执行resolve(data)时，传入的参数会被第一个then()接收
then()可以链式调用，可以通过return返回值向下层传递，

当return返回一个Promise对象时，后面的then将会被当做这个返回的Promise的第一个then来对待。

- 异常捕获
then会接收两个参数（函数），第一个参数会在执行resolve之后触发（还能传递参数），第二个参数会在执行reject之后触发，不建议使用第二个参数。
对于Promise中的异常处理，我们建议用catch方法，而不是then的第二个参数。

在若干个then串联之后，我们一般会在最后跟一个.catch来捕获异常

## process.nextTick
process.nextTick：把当前任务放在主栈的最后执行（当主栈执行完，先执行nextTick，然后才到等待队列中找）。

process.env.NODE_ENV：全局环境变量
真实项目，基于webpack打包配置时，往往需要区分不同环境下的不同操作，例如有开发环境、测试环境、生产环境...而我们一般都是基于环境变量来区分打包配置。


# 最后想说
哎呀，妈妈呀！学习芝士的心情贼好！！！


<- - - 本文 ღ 结束 - - - >