---
title: 深入理解JS系列-Part2（作用域和闭包）
date: 2017-10-20 11:53:05
categories: 读书笔记
tags:
- JavaScript
- 深入理解JS
---

本篇是***深入理解JS系列 ***的Part2：作用域和闭包。JavaScript中的作用域是区别与传统OO语言的，因此我们有必要简单的介绍一下。而闭包是这门语言中的一个新的概念，也是一个难点。

参考书籍：《JavaScript高级程序设计（第3版）》、《你不知道的JavaScript》
<!--more-->

# 作用域
## 概念
首先，作用域是什么？作用域是一个抽象的概念，就好像是一个“范围”。范围之内的属于私有变量，外部无法访问。
作用域主要有两种工作模型：
- 词法作用域
  是由***书写代码时函数声明的位置 ***决定的，是静态的。
- 动态作用域（仅作对比，了解即可）
  在***运行***时确定的，是动态的。只关注函数***在哪里调用***。（***this也是！！！***）

事实上，***JavaScript只有词法作用域 ***，并不具有动态作用域，而this机制也是关注函数在哪里调用的，很像动态作用域，俩人应该是表亲关系啦。



接下来介绍JavaScript的三种作用域（全局、函数、块）。

## ES6之前，JavaScript只有两种作用域
ES6之前，JavaScript只有全局作用域和函数作用域，并没有块作用域的概念，但却用立即执行函数表达式来模仿了块作用域。
### 全局作用域和函数作用域
- 全局作用域
  最顶层的作用域。在web浏览器中，所有的全局变量和函数都是作为window对象的属性和方法创建的。全局作用域直到程序退出，例如关闭浏览器或网页时才被销毁。
- 函数作用域
  每声明一个函数就会为其自身创建一个作用域，我们称之为私有作用域。
  在私有作用域中，只有两种情况是私有变量：
    + ***在函数内部声明过的变量和函数（带var和function）  ***
    + ***形参也是私有变量 ***
     =>剩下的都不是，都可以基于作用域链的机制向上查找
     私有变量只能在函数内部访问，不能在全局作用域中访问。
栗子：
```
var a = 1;
function foo() {
    var b = 2;
    console.log(b);//2
}
console.log(b); //ReferenceError
```
  在上栗中，变量a是一个全局变量，而变量b是一个局部变量，只存在与foo函数的作用域中，在foo函数的外部访问会抛ReferenceError（变量未声明）错误。

### 立即执行函数表达式
- 语法
```
(function() {
    //这里是块级作用域
})();
```
  将一个函数的值括起来，外面再加一个()立即调用，这样就模仿了一个块作用域。
  也可以写成(function() { .. }())，将调用()移进里边。两种写法都可以，个人比较稀罕第一种辣。
- 这里要讲一下原理
我们都知道变量只不过是值的一种形式，可以用实际的值来替换变量，比如
```
var num = 5;
output(num);
//等同于
output(5);
```
  而函数在使用函数表达式进行定义时，是将一个匿名函数赋值给一个变量，然后再用函数名来调用，那我们是不是也可以用函数的值直接替换函数名呢？当然可以
```
(function () {
    var b = 2;
    console.log(b);
})();
```
  注意：***函数的值一定要用()括起来***，否则会报错
- 应用
 - 传递参数
 我们可以通过调用()将外部作用域中的变量传递给函数的参数，函数的参数可以任意命名。由于函数是按值进行传递的，所以就会将外部作用域的变量的一个副本复制给函数的参数。
```
var a = 0;
(function (obj) {
    var a = 2;
    console.log(a); //2
    console.log(obj.a); //0
})(window);
```
在上边的栗子中，将window对象的一个副本复制给了参数obj，因此obj.a访问的是全局作用域中的a。

## ES6引入了块作用域
在其他C语言中，{ }包围的代码块都有自己的作用域。ES6在with、try/catch、let、const中引入了块作用域，将变量和函数的作用域限制在{ }内部。
- try/catch
  catch分句会创建块作用域，声明的变量仅在catch的{ }中有效。
```
try {
    undefined();//执行一个非法操作来强制一个异常
} catch (err) {
    err = 2
    console.log(err); //2
}
console.log(err); //ReferenceError
```
- let、const
ES6引入了let、const来声明变量，可以将声明的变量偷偷的劫持在所在的作用域。
```
function foo() {
    if (true) {
        let b = 2;
        const c = 3;
        var d = 4;
    }
    console.log(d); //4
    console.log(b); //ReferenceError
    console.log(c); //ReferenceError
}
```

## 作用域是可嵌套的
### 作用域链
作用域是可以嵌套的，嵌套的多个作用域形成了作用域链。
栗子：
```
var a = 1;
function foo() {
  var b = 2;
  console.log(a);
}
foo(); //1
console.log(b); //ReferenceError
```
在上面的栗子中，有两个作用域：
- 全局作用域，其对应的变量对象（window对象）包含两个标识符：a、foo
- foo所创建的作用域，其对应的变量对象只包含一个标识符：b
嵌套关系：foo作用域嵌套在全局作用域当中。

执行foo函数后，输出1，说明foo函数内的变量a可以访问全局作用域的变量a；而在全局作用域执行console.log(b)抛出ReferenceError，这说明全局作用域无法访问到foo函数内的变量b。

>这个栗子告诉我们：***作用域可嵌套，内层作用域可访问外层，外层作用域不可以访问内层。   ***



### 基于作用域链的查找机制
采取就近原则，始终***从当前作用域开始***，逐级向上查找，***直至找到第一个匹配的标识符为止***，否则会抵达最顶层的作用域（也就是全局作用域）继续查找。
栗子：
```
var a = 1;
function foo() {
    var a = 2;
    console.log(a); //2
}
```
在上栗中，当代码执行到console.log(a)，要查找a的引用，显然在foo作用域中就找到了a，查找过程停止。

再来看一个栗子：
```
var a = 12;
function foo() {
    console.log(a);
}
function bar() {
    var a = 13;
    foo();
}
bar();// 12
```
当foo()执行时，需要查找变量a，在foo作用域中没有找到a，我们需要基于词法作用域向上查找，***foo的上级作用域是由创建foo的位置决定的，和foo在哪调用没有关系。  ***因此foo的上级作用域是全局作用域，在全局作用域中找到了a = 12 ，查找过程停止。

这个栗子告诉我们：
>查找一个作用域的上级作用域是谁，和它***在哪执行没有关系，是由它在哪创建决定的。***

# 闭包
闭包是一个非常强大的工具，其实我们的代码中到处都有闭包存在，如果我们不认识闭包，也不理解它的工作原理，在使用的过程中就很容易出现一些诡异的错误，比如在循环中。
## 什么是闭包
我们来对闭包下一个定义：
***如果将一个函数传递到定义时的词法作用域之外执行，则它依然会保持对原始作用域的引用。这个引用就是闭包，它由两部分构成：函数，以及创建该函数的词法作用域。***
便于理解和识别闭包，我们先来看一个栗子吧。
```
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    bar();
}
foo(); //2
```
在这个栗子中，函数bar可以访问foo作用域中的变量a，这是闭包吗？？？
答案是：no no no
因为函数bar是在foo作用域内定义的，也是在foo函数内调用的。函数bar保持着对a的引用准确的说是通过***普通的词法作用域查找到的  ***，并不是真正的闭包。

下面，主角该登场了。。。
我们来看一下真正的闭包是什么酱紫的：
```
var a = 1;
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}
var closure = foo(); //————朋友快看呀，这个closure才是闭包！！！
closure(); //2 
```
在本栗中，函数bar并没有在函数foo内调用，而是被当做foo函数的一个返回值赋值给了变量closure，并立即执行了closure()。实际上，执行closure()就是在执行内部的bar()。函数bar()是在全局作用域中执行的，但却可以访问foo内部的变量a，这***完全违背了作用域链的访问原则
***，这一点是不是特别奇怪，到底是为什么捏？？？
因为在foo()执行后，通常foo的整个内部作用域会被立即销毁，然后再由垃圾回收器来释放foo的内存空间，而闭包的“神奇”之处就在于会阻止这件事情的发生，***foo作用域能够一直存活（尽管此时作用域链已经断开），但它的存在仅仅是供bar函数引用，一旦bar函数执行完毕就会随之被销毁。***

>注意：闭包所保存的是foo的整个内部作用域的引用，并不是某一个特殊的变量。

## 应用
两大作用：
- 保护：保护私有变量不受外界的干扰  
- 保存：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用

### 保存状态/缓存
- 在for循环中创建函数，会为每次迭代创建一个闭包



### ES6的模块机制就是基于闭包设计的
ES6引入了模块机制，一个模块对应一个文件，同时也对应一个私有的作用域。export可以将当前模块的一个标识符（变量、函数）导出为公共API，import会将模块的一个或多个API导入当前作用域。在import后面导入的绑定就是一个闭包，包含了对导入模块作用域的引用。详见《你不知道的JavaScript 上卷》第5章5.5节。

## 注意
为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少对闭包的使用（不销毁的堆栈内存是耗性能的）。


# 经典的for循环题
- 使用var
我们知道，如果使用var声明for循环中的循环变量i，i就会泄露为全局变量，来看下面的栗子
```
var funcs = [];
for (var i = 0; i < 10; i++) {
    funcs[i] = function() {
        console.log(i);
    };
}
funcs.forEach(item => item()); //输出10个10
```
funcs是一个函数数组，表明上看，每个函数都应该返回自己的索引值，然而事实上，每个函数都返回10，这是为什么捏？？？因为每个函数中都保存着其父作用域中的活动对象（这里是window），它们引用的是同一个变量i。
- 使用IIFE
为解决这个问题，可以使用立即函数表达式，通过传递参数来强制生成i的副本，代码如下：
```
var funcs = [];
for (var i = 0; i < 10; i++) {
    funcs[i] = (function(num) {
        return function() {
            console.log(num);
        };
    })(i);
}
funcs.forEach(item => item()); //输出0-9
```
在上边的栗子中，将变量i的当前值的一个副本复制给了参数num，而在这个匿名函数内部，又创建并返回了一个闭包。这样一来，数组中的每个函数都有各自num变量的一个副本，因此可以返回各自不同的数值。
- 使用let
使用let可达到相同的效果，而且代码非常简洁，代码如下：
```
var funcs = [];
for (let i = 0; i < 10; i++) {
    funcs[i] = function() {
        console.log(i);
    };
}
funcs.forEach(item => item()); //输出0-9
```
每次迭代let都会重新声明一个新变量i，并将其初始化为上一次迭代结束时的值，所以循环内部创建的每个函数都能得到属于它们自己i的副本了。

<- - - 本文 ღ 结束 - - - >